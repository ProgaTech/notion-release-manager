name: Release Manager - Main

on:
  workflow_call:
    inputs:
      main_branch:
        description: "Main branch name"
        required: false
        type: string
        default: "main"
      release_stage_property:
        description: "Notion property name for release stage"
        required: false
        type: string
        default: "Status"
      release_property:
        description: "Notion property name for release relation"
        required: false
        type: string
        default: "Release"
      release_stage_prod:
        description: "Release stage value for prod environment"
        required: false
        type: string
        default: "On Prod"
      next_release_name:
        description: "Name for the next/pending release"
        required: false
        type: string
        default: "Next Release"
      release_status_next:
        description: "Release status value for next/pending releases"
        required: false
        type: string
        default: "Next"
      release_status_released:
        description: "Release status value for released versions"
        required: false
        type: string
        default: "Released"
      release_label_property:
        description: "Notion property name for release labels"
        required: false
        type: string
        default: "Release Label"
      release_label_major:
        description: "PR label for major version bump"
        required: false
        type: string
        default: "Major"
      release_label_minor:
        description: "PR label for minor version bump"
        required: false
        type: string
        default: "Minor"
      release_label_patch:
        description: "PR label for patch version bump"
        required: false
        type: string
        default: "Patch"
      release_stage_dev:
        description: "Release stage value for dev environment"
        required: false
        type: string
        default: "On Dev"
    secrets:
      NOTION_API_TOKEN:
        required: true
      NOTION_TASKS_DATABASE_ID:
        required: true
      NOTION_RELEASES_DATABASE_ID:
        required: true

permissions:
  contents: write
  pull-requests: read

jobs:
  promote-to-release:
    runs-on: ubuntu-latest
    env:
      MAIN_BRANCH: ${{ inputs.main_branch }}
      RELEASE_STAGE_PROPERTY: ${{ inputs.release_stage_property }}
      RELEASE_PROPERTY: ${{ inputs.release_property }}
      RELEASE_STAGE_PROD: ${{ inputs.release_stage_prod }}
      NEXT_RELEASE_NAME: ${{ inputs.next_release_name }}
      RELEASE_STATUS_NEXT: ${{ inputs.release_status_next }}
      RELEASE_STATUS_RELEASED: ${{ inputs.release_status_released }}
      RELEASE_LABEL_PROPERTY: ${{ inputs.release_label_property }}
      RELEASE_LABEL_MAJOR: ${{ inputs.release_label_major }}
      RELEASE_LABEL_MINOR: ${{ inputs.release_label_minor }}
      RELEASE_LABEL_PATCH: ${{ inputs.release_label_patch }}
      RELEASE_STAGE_DEV: ${{ inputs.release_stage_dev }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Promote to release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require("child_process");
            function tryExec(cmd) {
              try {
                return execSync(cmd).toString().trim();
              } catch {
                return "";
              }
            }

            async function sleep(ms) {
              return new Promise(r => setTimeout(r, ms));
            }

            const notionApi = "https://api.notion.com/v1";
            const notionToken = "${{ secrets.NOTION_API_TOKEN }}";
            const tasksDB = "${{ secrets.NOTION_TASKS_DATABASE_ID }}";
            const releasesDB = "${{ secrets.NOTION_RELEASES_DATABASE_ID }}";

            const headers = {
              "Authorization": `Bearer ${notionToken}`,
              "Notion-Version": "2022-06-28",
              "Content-Type": "application/json"
            };

            async function queryNotionDB(db, body) {
              const res = await fetch(`${notionApi}/databases/${db}/query`, {
                method: "POST",
                headers,
                body: JSON.stringify(body)
              });
              if (!res.ok) throw new Error(`Query failed: ${res.status} ${await res.text()}`);
              return res.json();
            }

            async function patchPage(pageId, properties) {
              const res = await fetch(`${notionApi}/pages/${pageId}`, {
                method: "PATCH",
                headers,
                body: JSON.stringify({ properties })
              });
              if (!res.ok) throw new Error(`Patch failed: ${res.status} ${await res.text()}`);
              return res.json();
            }

            async function createPage(db, properties) {
              const res = await fetch(`${notionApi}/pages`, {
                method: "POST",
                headers,
                body: JSON.stringify({ parent: { database_id: db }, properties, template: { type: "default" } })
              });
              if (!res.ok) throw new Error(`Create failed: ${res.status} ${await res.text()}`);
              return res.json();
            }

            async function getLatestReleasedVersion() {
              const res = await queryNotionDB(releasesDB, {
                filter: {
                  property: "Status",
                  select: { equals: process.env.RELEASE_STATUS_RELEASED }
                },
                sorts: [{ property: "Version", direction: "descending" }]
              });
              if (!res.results.length) return "0.0.0";
              return res.results[0].properties.Version.title[0].plain_text;
            }

            async function ensureRelease(version, status) {
              const found = await queryNotionDB(releasesDB, {
                filter: { property: "Version", title: { equals: version } }
              });
              if (found.results.length) return found.results[0].id;
              const page = await createPage(releasesDB, {
                Version: { title: [{ text: { content: version } }] },
                Status: { select: { name: status } },
                "Release Date": { date: { start: new Date().toISOString() } }
              });
              return page.id;
            }

            async function getNextReleaseTasks() {
              const tasks = await queryNotionDB(tasksDB, {
                filter: {
                  and: [
                    { property: RELEASE_REL_PROP, relation: { contains: nextReleaseId } },
                    { property: RELEASE_STAGE_PROP, select: { equals: DEV_STAGE } }
                  ]
                }
              });
              return tasks.results;
            }

            function bumpVersion(base, strategy) {
              const p = base.split(".").map(Number);
              if (strategy === "major") return `${p[0] + 1}.0.0`;
              if (strategy === "minor") return `${p[0]}.${p[1] + 1}.0`;
              return `${p[0]}.${p[1]}.${p[2] + 1}`;
            }

            function maxBump(a, b) {
              const order = { patch: 0, minor: 1, major: 2 };
              return order[b] > order[a] ? b : a;
            }

            const RELEASE_STAGE_PROP = process.env.RELEASE_STAGE_PROPERTY;
            const RELEASE_REL_PROP = process.env.RELEASE_PROPERTY;
            const RELEASE_LABEL_PROP = process.env.RELEASE_LABEL_PROPERTY;
            const DEV_STAGE = process.env.RELEASE_STAGE_DEV;
            const PROD_STAGE = process.env.RELEASE_STAGE_PROD;
            const RELEASE_LABEL_MAJOR = process.env.RELEASE_LABEL_MAJOR;
            const RELEASE_LABEL_MINOR = process.env.RELEASE_LABEL_MINOR;
            const RELEASE_LABEL_PATCH = process.env.RELEASE_LABEL_PATCH;
            const nextReleaseName = process.env.NEXT_RELEASE_NAME;
            const statusNext = process.env.RELEASE_STATUS_NEXT;
            const statusReleased = process.env.RELEASE_STATUS_RELEASED;
            const nextReleaseId = await ensureRelease(nextReleaseName, statusNext);
            console.log(`Pending release page: "${nextReleaseName}" (${nextReleaseId})`);

            // Get latest released version from Notion (source of truth)
            const latest = await getLatestReleasedVersion();
            console.log(`Latest released version from Notion: ${latest}`);

            // Determine version bump based on Release Note labels from Notion tasks
            // Only consider tasks that are fully on dev (not partially)
            let calculatedBump = "patch";
            let nextReleaseTasks = [];
            try {
              nextReleaseTasks = await getNextReleaseTasks();

              console.log(`Found ${nextReleaseTasks.length} tasks in "${nextReleaseName}" on dev for bump calculation`);

              for (const task of nextReleaseTasks) {
                const releaseLabelProp = task.properties[RELEASE_LABEL_PROP];
                if (!releaseLabelProp || releaseLabelProp.type !== 'select' || !releaseLabelProp.select) {
                  // No label set, default to patch
                  calculatedBump = maxBump(calculatedBump, "patch");
                  continue;
                }

                const labelValue = releaseLabelProp.select.name;
                console.log(`Task ${task.id} has Release Label: "${labelValue}"`);

                if (labelValue === RELEASE_LABEL_MAJOR) {
                  calculatedBump = maxBump(calculatedBump, "major");
                } else if (labelValue === RELEASE_LABEL_MINOR) {
                  calculatedBump = maxBump(calculatedBump, "minor");
                } else if (labelValue === RELEASE_LABEL_PATCH) {
                  calculatedBump = maxBump(calculatedBump, "patch");
                } else {
                  // Unknown label, default to patch
                  calculatedBump = maxBump(calculatedBump, "patch");
                }
              }

              console.log(`Version bump determined from Notion task labels: ${calculatedBump}`);
            } catch (e) {
              console.log(`Error determining bump from Notion tasks: ${e.message}, defaulting to patch`);
            }

            const nextVersion = bumpVersion(latest, calculatedBump);
            console.log(`Next version: ${nextVersion} (base: ${latest}, bump: ${calculatedBump})`);
            const prodReleaseId = await ensureRelease(nextVersion, statusReleased);

            // Promote tasks from "Next Release" to the new version
            // Only promote tasks that are fully on dev (not partially)
            try {
              console.log(`Promoting ${nextReleaseTasks.length} tasks from "${nextReleaseName}" to ${nextVersion}`);
              
              for (const task of nextReleaseTasks) {
                try {
                  const props = {
                    [RELEASE_REL_PROP]: { relation: [{ id: prodReleaseId }] },
                    [RELEASE_STAGE_PROP]: { select: { name: PROD_STAGE } },
                    "Release Date": { date: { start: new Date().toISOString() } }
                  };
                  await patchPage(task.id, props);
                  await sleep(300);
                } catch (e) {
                  console.log(`Error promoting task ${task.id}: ${e.message}`);
                }
              }
            } catch (e) {
              console.log(`Error querying tasks for promotion: ${e.message}`);
            }

            // Create git tag
            try {
              execSync(`git config user.name "GitHub Actions"`);
              execSync(`git config user.email "actions@github.com"`);
              const tagName = `v${nextVersion}`;
              const exists = tryExec(`git rev-parse ${tagName}`);
              if (!exists) {
                execSync(`git tag -a ${tagName} -m "Release ${tagName}"`);
                execSync(`git push origin ${tagName}`);
                console.log(`Created git tag ${tagName}`);
              } else {
                console.log(`Tag ${tagName} already exists, skipping creation`);
              }
            } catch (e) {
              console.log(`Error creating git tag: ${e.message}`);
            }
